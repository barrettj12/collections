// Code generated by github.com/barrettj12/collections/internal/gen. DO NOT EDIT.
// Generated from package "strings", version go1.19.4
package collections

import "strings"

// Clone returns a fresh copy of s.
// It guarantees to make a copy of s into a new allocation,
// which can be important when retaining only a small substring
// of a much larger string. Using Clone can help such programs
// use less memory. Of course, since using Clone makes a copy,
// overuse of Clone can make programs use more memory.
// Clone should typically be used only rarely, and only when
// profiling indicates that it is needed.
// For strings of length zero the string "" will be returned
// and no allocation is made.
func (s *String) Clone() string {
	return strings.Clone(string(*s))
}

// Compare returns an integer comparing two strings lexicographically.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b.
//
// Compare is included only for symmetry with package bytes.
// It is usually clearer and always faster to use the built-in
// string comparison operators ==, <, >, and so on.
func (s *String) Compare(b string) int {
	return strings.Compare(string(*s), b)
}

// NewReader returns a new Reader reading from s.
// It is similar to bytes.NewBufferString but more efficient and read-only.
func (s *String) NewReader() *strings.Reader {
	return strings.NewReader(string(*s))
}

// Count counts the number of non-overlapping instances of substr in s.
// If substr is an empty string, Count returns 1 + the number of Unicode code points in s.
func (s *String) Count(substr string) int {
	return strings.Count(string(*s), substr)
}

// Contains reports whether substr is within s.
func (s *String) Contains(substr string) bool {
	return strings.Contains(string(*s), substr)
}

// ContainsAny reports whether any Unicode code points in chars are within s.
func (s *String) ContainsAny(chars string) bool {
	return strings.ContainsAny(string(*s), chars)
}

// ContainsRune reports whether the Unicode code point r is within s.
func (s *String) ContainsRune(r rune) bool {
	return strings.ContainsRune(string(*s), r)
}

// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.
func (s *String) LastIndex(substr string) int {
	return strings.LastIndex(string(*s), substr)
}

// IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.
func (s *String) IndexByte(c byte) int {
	return strings.IndexByte(string(*s), c)
}

// IndexRune returns the index of the first instance of the Unicode code point
// r, or -1 if rune is not present in s.
// If r is utf8.RuneError, it returns the first instance of any
// invalid UTF-8 byte sequence.
func (s *String) IndexRune(r rune) int {
	return strings.IndexRune(string(*s), r)
}

// IndexAny returns the index of the first instance of any Unicode code point
// from chars in s, or -1 if no Unicode code point from chars is present in s.
func (s *String) IndexAny(chars string) int {
	return strings.IndexAny(string(*s), chars)
}

// LastIndexAny returns the index of the last instance of any Unicode code
// point from chars in s, or -1 if no Unicode code point from chars is
// present in s.
func (s *String) LastIndexAny(chars string) int {
	return strings.LastIndexAny(string(*s), chars)
}

// LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.
func (s *String) LastIndexByte(c byte) int {
	return strings.LastIndexByte(string(*s), c)
}

// SplitN slices s into substrings separated by sep and returns a slice of
// the substrings between those separators.
//
// The count determines the number of substrings to return:
//
//	n > 0: at most n substrings; the last substring will be the unsplit remainder.
//	n == 0: the result is nil (zero substrings)
//	n < 0: all substrings
//
// Edge cases for s and sep (for example, empty strings) are handled
// as described in the documentation for Split.
//
// To split around the first instance of a separator, see Cut.
func (s *String) SplitN(sep string, n int) []string {
	return strings.SplitN(string(*s), sep, n)
}

// SplitAfterN slices s into substrings after each instance of sep and
// returns a slice of those substrings.
//
// The count determines the number of substrings to return:
//
//	n > 0: at most n substrings; the last substring will be the unsplit remainder.
//	n == 0: the result is nil (zero substrings)
//	n < 0: all substrings
//
// Edge cases for s and sep (for example, empty strings) are handled
// as described in the documentation for SplitAfter.
func (s *String) SplitAfterN(sep string, n int) []string {
	return strings.SplitAfterN(string(*s), sep, n)
}

// Split slices s into all substrings separated by sep and returns a slice of
// the substrings between those separators.
//
// If s does not contain sep and sep is not empty, Split returns a
// slice of length 1 whose only element is s.
//
// If sep is empty, Split splits after each UTF-8 sequence. If both s
// and sep are empty, Split returns an empty slice.
//
// It is equivalent to SplitN with a count of -1.
//
// To split around the first instance of a separator, see Cut.
func (s *String) Split(sep string) []string {
	return strings.Split(string(*s), sep)
}

// SplitAfter slices s into all substrings after each instance of sep and
// returns a slice of those substrings.
//
// If s does not contain sep and sep is not empty, SplitAfter returns
// a slice of length 1 whose only element is s.
//
// If sep is empty, SplitAfter splits after each UTF-8 sequence. If
// both s and sep are empty, SplitAfter returns an empty slice.
//
// It is equivalent to SplitAfterN with a count of -1.
func (s *String) SplitAfter(sep string) []string {
	return strings.SplitAfter(string(*s), sep)
}

// Fields splits the string s around each instance of one or more consecutive white space
// characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an
// empty slice if s contains only white space.
func (s *String) Fields() []string {
	return strings.Fields(string(*s))
}

// FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)
// and returns an array of slices of s. If all code points in s satisfy f(c) or the
// string is empty, an empty slice is returned.
//
// FieldsFunc makes no guarantees about the order in which it calls f(c)
// and assumes that f always returns the same value for a given c.
func (s *String) FieldsFunc(f func(rune) bool) []string {
	return strings.FieldsFunc(string(*s), f)
}

// HasPrefix tests whether the string s begins with prefix.
func (s *String) HasPrefix(prefix string) bool {
	return strings.HasPrefix(string(*s), prefix)
}

// HasSuffix tests whether the string s ends with suffix.
func (s *String) HasSuffix(suffix string) bool {
	return strings.HasSuffix(string(*s), suffix)
}

// Repeat returns a new string consisting of count copies of the string s.
//
// It panics if count is negative or if
// the result of (len(s) * count) overflows.
func (s *String) Repeat(count int) string {
	return strings.Repeat(string(*s), count)
}

// ToUpper modifies s so that it has all Unicode letters mapped to their upper case.
func (s *String) ToUpper() {
	*s = String(strings.ToUpper(string(*s)))
}

// ToLower modifies s so that it has all Unicode letters mapped to their lower case.
func (s *String) ToLower() {
	*s = String(strings.ToLower(string(*s)))
}

// ToTitle modifies s so that it has all Unicode letters mapped to
// their Unicode title case.
func (s *String) ToTitle() {
	*s = String(strings.ToTitle(string(*s)))
}

// ToValidUTF8 modifies s so that it has each run of invalid UTF-8 byte sequences
// replaced by the replacement string, which may be empty.
func (s *String) ToValidUTF8(replacement string) {
	*s = String(strings.ToValidUTF8(string(*s), replacement))
}

// Title modifies s so that it has all Unicode letters that begin words
// mapped to their Unicode title case.
//
// Deprecated: The rule Title uses for word boundaries does not handle Unicode
// punctuation properly. Use golang.org/x/text/cases instead.
func (s *String) Title() {
	*s = String(strings.Title(string(*s)))
}

// TrimLeftFunc modifies s so that it has all leading
// Unicode code points c satisfying f(c) removed.
func (s *String) TrimLeftFunc(f func(rune) bool) {
	*s = String(strings.TrimLeftFunc(string(*s), f))
}

// TrimRightFunc modifies s so that it has all trailing
// Unicode code points c satisfying f(c) removed.
func (s *String) TrimRightFunc(f func(rune) bool) {
	*s = String(strings.TrimRightFunc(string(*s), f))
}

// TrimFunc modifies s so that it has all leading
// and trailing Unicode code points c satisfying f(c) removed.
func (s *String) TrimFunc(f func(rune) bool) {
	*s = String(strings.TrimFunc(string(*s), f))
}

// IndexFunc returns the index into s of the first Unicode
// code point satisfying f(c), or -1 if none do.
func (s *String) IndexFunc(f func(rune) bool) int {
	return strings.IndexFunc(string(*s), f)
}

// LastIndexFunc returns the index into s of the last
// Unicode code point satisfying f(c), or -1 if none do.
func (s *String) LastIndexFunc(f func(rune) bool) int {
	return strings.LastIndexFunc(string(*s), f)
}

// Trim modifies s so that it has all leading and
// trailing Unicode code points contained in cutset removed.
func (s *String) Trim(cutset string) {
	*s = String(strings.Trim(string(*s), cutset))
}

// TrimLeft modifies s so that it has all leading
// Unicode code points contained in cutset removed.
//
// To remove a prefix, use TrimPrefix instead.
func (s *String) TrimLeft(cutset string) {
	*s = String(strings.TrimLeft(string(*s), cutset))
}

// TrimRight modifies s so that it has all trailing
// Unicode code points contained in cutset removed.
//
// To remove a suffix, use TrimSuffix instead.
func (s *String) TrimRight(cutset string) {
	*s = String(strings.TrimRight(string(*s), cutset))
}

// TrimSpace modifies s so that it has all leading
// and trailing white space removed, as defined by Unicode.
func (s *String) TrimSpace() {
	*s = String(strings.TrimSpace(string(*s)))
}

// TrimPrefix removes from s the provided leading prefix string.
// If s doesn't start with prefix, s is returned unchanged.
func (s *String) TrimPrefix(prefix string) {
	*s = String(strings.TrimPrefix(string(*s), prefix))
}

// TrimSuffix removes from s the provided trailing suffix string.
// If s doesn't end with suffix, s is returned unchanged.
func (s *String) TrimSuffix(suffix string) {
	*s = String(strings.TrimSuffix(string(*s), suffix))
}

// Replace modifies s so that it has the first n
// non-overlapping instances of old replaced by new.
// If old is empty, it matches at the beginning of the string
// and after each UTF-8 sequence, yielding up to k+1 replacements
// for a k-rune string.
// If n < 0, there is no limit on the number of replacements.
func (s *String) Replace(old, new string, n int) {
	*s = String(strings.Replace(string(*s), old, new, n))
}

// ReplaceAll modifies s so that it has all
// non-overlapping instances of old replaced by new.
// If old is empty, it matches at the beginning of the string
// and after each UTF-8 sequence, yielding up to k+1 replacements
// for a k-rune string.
func (s *String) ReplaceAll(old, new string) {
	*s = String(strings.ReplaceAll(string(*s), old, new))
}

// EqualFold reports whether s and t, interpreted as UTF-8 strings,
// are equal under simple Unicode case-folding, which is a more general
// form of case-insensitivity.
func (s *String) EqualFold(t string) bool {
	return strings.EqualFold(string(*s), t)
}

// Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.
func (s *String) Index(substr string) int {
	return strings.Index(string(*s), substr)
}

// Cut slices s around the first instance of sep,
// returning the text before and after sep.
// The found result reports whether sep appears in s.
// If sep does not appear in s, cut returns s, "", false.
func (s *String) Cut(sep string) (before, after string, found bool) {
	return strings.Cut(string(*s), sep)
}
